import { TFile, Notice } from "obsidian";
import type ProjectPlannerPlugin from "../main";
import type { PlannerTask } from "../types";

export class ProjectHubManager {
    private plugin: ProjectPlannerPlugin;

    constructor(plugin: ProjectPlannerPlugin) {
        this.plugin = plugin;
    }

    /**
     * Open the Project Hub if it exists, or prompt to create it and then open.
     */
    async openOrCreateProjectHub(projectName: string): Promise<void> {
        const hubPath = `Project Planner/Hubs/${projectName} Hub.md`;
        const file = this.plugin.app.vault.getAbstractFileByPath(hubPath);

        const open = async () => {
            const openInNewTab = (this.plugin as any).settings?.openLinksInNewTab ?? false;
            const leaf = this.plugin.app.workspace.getLeaf(!openInNewTab);
            if (file) {
                await (leaf as any).openFile(file as any);
            } else {
                const newFile = this.plugin.app.vault.getAbstractFileByPath(hubPath);
                if (newFile) {
                    await (leaf as any).openFile(newFile as any);
                }
            }
        };

        if (file) {
            await open();
            return;
        }

        const shouldCreate = confirm(
            `Project Hub for "${projectName}" doesn't exist yet. Create it now?`
        );
        if (!shouldCreate) return;

        await this.createOrUpdateProjectHub(projectName, this.getTasksForActiveProject());

        // Give vault a moment to register the new file
        setTimeout(async () => {
            await open();
        }, 300);
    }

    private getTasksForActiveProject(): PlannerTask[] {
        const gridLeaves = this.plugin.app.workspace.getLeavesOfType("project-planner-view");
        if (gridLeaves.length > 0) {
            const grid: any = gridLeaves[0].view;
            if (grid && grid.taskStore) {
                return grid.taskStore.getAll();
            }
        }
        const store = (this.plugin as any).taskStore;
        if (store) {
            return store.getAll();
        }
        return [];
    }

    /**
     * Create or update a Project Hub note for the current project
     */
    async createOrUpdateProjectHub(projectName: string, tasks: PlannerTask[]): Promise<void> {
        const hubPath = `Project Planner/Hubs/${projectName} Hub.md`;

        // Check if file exists
        let file = this.plugin.app.vault.getAbstractFileByPath(hubPath);

        const content = this.generateHubContent(projectName, tasks);

        if (file instanceof TFile) {
            // Update existing file
            await this.plugin.app.vault.modify(file, content);
            new Notice(`Updated ${projectName} Hub`);
        } else {
            // Create new file (and folder if needed)
            try {
                await this.plugin.app.vault.create(hubPath, content);
                new Notice(`Created ${projectName} Hub`);
            } catch (error) {
                // Folder might not exist
                await this.plugin.app.vault.createFolder("Project Planner/Hubs").catch(() => { });
                await this.plugin.app.vault.create(hubPath, content);
                new Notice(`Created ${projectName} Hub`);
            }
        }
    }

    private generateHubContent(projectName: string, tasks: PlannerTask[]): string {
        const now = new Date().toISOString().split('T')[0];

        let content = `# ${projectName}\n\n`;
        content += `> Project Hub - Generated by Project Planner\n`;
        content += `> Last updated: ${now}\n\n`;

        // Project overview
        const totalTasks = tasks.length;
        const completedTasks = tasks.filter(t => t.status === "Completed").length;
        const inProgressTasks = tasks.filter(t => t.status === "In Progress").length;
        const blockedTasks = tasks.filter(t => t.status === "Blocked").length;
        const notStartedTasks = tasks.filter(t => t.status === "Not Started").length;

        content += `## ðŸ“Š Project Overview\n\n`;
        content += `- **Total Tasks**: ${totalTasks}\n`;
        content += `- **Completed**: ${completedTasks} (${totalTasks > 0 ? Math.round(completedTasks / totalTasks * 100) : 0}%)\n`;
        content += `- **In Progress**: ${inProgressTasks}\n`;
        content += `- **Blocked**: ${blockedTasks}\n`;
        content += `- **Not Started**: ${notStartedTasks}\n\n`;

        // Progress bar
        const progressPercent = totalTasks > 0 ? Math.round(completedTasks / totalTasks * 100) : 0;
        const progressBlocks = Math.round(progressPercent / 5);
        const progressBar = "â–ˆ".repeat(progressBlocks) + "â–‘".repeat(20 - progressBlocks);
        content += `**Progress**: ${progressBar} ${progressPercent}%\n\n`;

        // Tasks by status
        content += `## ðŸ“‹ Tasks by Status\n\n`;

        if (inProgressTasks > 0) {
            content += `### ðŸ”µ In Progress\n`;
            tasks.filter(t => t.status === "In Progress").forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        if (blockedTasks > 0) {
            content += `### ðŸ”´ Blocked\n`;
            tasks.filter(t => t.status === "Blocked").forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        if (notStartedTasks > 0) {
            content += `### âšª Not Started\n`;
            tasks.filter(t => t.status === "Not Started").forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        if (completedTasks > 0) {
            content += `### âœ… Completed\n`;
            tasks.filter(t => t.status === "Completed").forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        // Tasks by priority
        const highPriorityTasks = tasks.filter(t => t.priority === "High" || t.priority === "Critical");
        if (highPriorityTasks.length > 0) {
            content += `## âš¡ High Priority Tasks\n\n`;
            highPriorityTasks.forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        // Overdue tasks
        const now_date = new Date();
        const overdueTasks = tasks.filter(t => {
            if (!t.dueDate || t.status === "Completed") return false;
            const dueDate = new Date(t.dueDate);
            return dueDate < now_date;
        });

        if (overdueTasks.length > 0) {
            content += `## âš ï¸ Overdue Tasks\n\n`;
            overdueTasks.forEach(task => {
                content += this.formatTaskLink(task);
            });
            content += '\n';
        }

        // Dependencies overview
        const tasksWithDeps = tasks.filter(t => (t.dependencies || []).length > 0);
        if (tasksWithDeps.length > 0) {
            content += `## ðŸ”— Task Dependencies\n\n`;
            content += `${tasksWithDeps.length} tasks have dependencies. `;
            content += `Open the Dependency Graph view for visualization.\n\n`;
        }

        // Linked resources
        const allLinks = tasks.flatMap(t => (t.links || []));
        const obsidianLinks = allLinks.filter(l => l.type === "obsidian");

        if (obsidianLinks.length > 0) {
            content += `## ðŸ“š Related Notes\n\n`;
            const uniqueLinks = Array.from(new Set(obsidianLinks.map(l => l.url)));
            uniqueLinks.forEach(url => {
                content += `- [[${url}]]\n`;
            });
            content += '\n';
        }

        // Footer
        content += `---\n\n`;
        content += `*This hub was automatically generated by the Obsidian Project Planner plugin.*\n`;

        return content;
    }

    private formatTaskLink(task: PlannerTask): string {
        let line = `- `;

        // Status indicator
        if (task.status === "Completed") {
            line += `[x] `;
        } else {
            line += `[ ] `;
        }

        // Priority indicator
        if (task.priority === "Critical") line += `ðŸ”¥ `;
        else if (task.priority === "High") line += `âš¡ `;

        // Task title with URI link
        const pluginAny = this.plugin as any;
        const projectId = pluginAny.settings?.activeProjectId || "";
        const taskUri = `obsidian://open-planner-task?id=${encodeURIComponent(task.id)}&project=${encodeURIComponent(projectId)}`;
        line += `[**${task.title}**](${taskUri})`;

        // Due date
        if (task.dueDate) {
            const dueDate = new Date(task.dueDate).toISOString().split('T')[0];
            line += ` - Due: ${dueDate}`;
        }

        // Tags
        if (task.tags && task.tags.length > 0) {
            line += ` `;
            task.tags.forEach(tagId => {
                // Get tag name from settings
                const settings: any = this.plugin.settings;
                const tag = (settings.availableTags || []).find((t: any) => t.id === tagId);
                if (tag) {
                    line += `#${tag.name.replace(/\s+/g, '-')} `;
                }
            });
        }

        line += '\n';
        return line;
    }

    /**
     * Create a dedicated note for a task
     */
    async createTaskNote(task: PlannerTask, projectName: string): Promise<string> {
        const notePath = `Project Planner/Tasks/${projectName}/${task.title.replace(/[/\\:*?"<>|]/g, '-')}.md`;

        let file = this.plugin.app.vault.getAbstractFileByPath(notePath);

        if (file instanceof TFile) {
            // File already exists
            return notePath;
        }

        // Create task note content
        const pluginAny = this.plugin as any;
        const projectId = pluginAny.settings?.activeProjectId || "";
        const taskUri = `obsidian://open-planner-task?id=${encodeURIComponent(task.id)}&project=${encodeURIComponent(projectId)}`;

        let content = `# ${task.title}\n\n`;
        content += `[ðŸ”— Open in Project Planner](${taskUri})\n\n`;
        content += `> Task from [[${projectName} Hub|${projectName}]]\n\n`;

        content += `## Details\n\n`;
        content += `- **Status**: ${task.status}\n`;
        if (task.priority) content += `- **Priority**: ${task.priority}\n`;
        if (task.startDate) content += `- **Start Date**: ${new Date(task.startDate).toISOString().split('T')[0]}\n`;
        if (task.dueDate) content += `- **Due Date**: ${new Date(task.dueDate).toISOString().split('T')[0]}\n`;

        if (task.tags && task.tags.length > 0) {
            content += `- **Tags**: `;
            task.tags.forEach(tagId => {
                const settings: any = this.plugin.settings;
                const tag = (settings.availableTags || []).find((t: any) => t.id === tagId);
                if (tag) {
                    content += `#${tag.name.replace(/\s+/g, '-')} `;
                }
            });
            content += '\n';
        }

        if (task.description) {
            content += `\n## Description\n\n${task.description}\n`;
        }

        if (task.links && task.links.length > 0) {
            content += `\n## Links\n\n`;
            task.links.forEach(link => {
                if (link.type === "obsidian") {
                    content += `- [[${link.url}|${link.title}]]\n`;
                } else {
                    content += `- [${link.title}](${link.url})\n`;
                }
            });
        }

        if (task.dependencies && task.dependencies.length > 0) {
            content += `\n## Dependencies\n\n`;
            content += `This task depends on:\n`;
            task.dependencies.forEach(dep => {
                content += `- ${dep.type}: (Task ID: ${dep.predecessorId})\n`;
            });
        }

        content += `\n---\n\n`;
        content += `*Managed by Obsidian Project Planner*\n`;

        // Create the file
        try {
            // Ensure parent folders exist
            const folders = notePath.split('/');
            folders.pop(); // Remove filename
            let currentPath = '';
            for (const folder of folders) {
                currentPath += folder;
                await this.plugin.app.vault.createFolder(currentPath).catch(() => { });
                currentPath += '/';
            }

            await this.plugin.app.vault.create(notePath, content);
            new Notice(`Created task note: ${task.title}`);
        } catch (error) {
            console.error("Error creating task note:", error);
        }

        return notePath;
    }

    /**
     * Add backlink to a note when task links to it
     */
    async addBacklinkToNote(notePath: string, taskTitle: string, projectName: string): Promise<void> {
        const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
        if (!(file instanceof TFile)) {
            return;
        }

        const content = await this.plugin.app.vault.read(file);

        // Check if backlink already exists
        const backlinkSection = `## ðŸ”— Linked from Project Planner`;
        const backlinkLine = `- **${taskTitle}** (from [[${projectName} Hub|${projectName}]])`;

        if (content.includes(backlinkLine)) {
            // Already has this backlink
            return;
        }

        let newContent = content;

        if (content.includes(backlinkSection)) {
            // Add to existing section
            const sectionIndex = content.indexOf(backlinkSection);
            const nextSectionIndex = content.indexOf('\n## ', sectionIndex + 1);
            const insertIndex = nextSectionIndex === -1 ? content.length : nextSectionIndex;

            newContent = content.slice(0, insertIndex) + `${backlinkLine}\n` + content.slice(insertIndex);
        } else {
            // Add new section at the end
            newContent += `\n\n${backlinkSection}\n\n${backlinkLine}\n`;
        }

        await this.plugin.app.vault.modify(file, newContent);
    }
}
